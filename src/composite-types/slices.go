package main

import (
	"fmt"
	"reflect"
	"sort"
)

/*
Раз длина массива — это часть его типа, то массивы не подходят для хранения коллекций данных динамического размера.
Эту задачу решает другой тип данных, который гораздо чаще используется на практике, — слайс (от англ. slice), или срез.
Кроме того, слайс избавит нас от проблемы копирования массивов для присваивания.
Слайс — это последовательность переменной длины, состоящая из элементов одного типа.
Тип слайса записывается как тип массива без указания размера.
Можно инициализировать переменную типа «слайс» значениями, но, в отличие от массива, переменная без инициализации равна nil.

Слайс — это обёртка над указателем массива, и в Go слайс используется как структура следующего вида:
- указатель на первый элемент базового массива — ptr;
- длина слайса — len, количество элементов в слайсе;
- ёмкость слайса — cap, количество элементов в массиве.
*/

func main() {
	var mySlice []int

	// Для создания слайса используется встроенная функция make():
	mySlice2 := make([]int, 5)     // слайс [0 0 0 0 0], базовый массив [0 0 0 0 0]
	mySlice3 := make([]int, 5, 10) // слайс [0 0 0 0 0], базовый массив [0 0 0 0 0 0 0 0 0 0]
	/*
		Аргументы функции make:
		Тип слайса (пустые квадратные скобки и тип элемента слайса).
		Длина слайса. Если не передана, то по умолчанию равна нулю.
		Ёмкость слайса — размер базового массива. Если значение не передано, то по умолчанию равна длине слайса.
	*/

	a := []int{1, 2, 3, 4}
	a = append(a, 20) // Добавление элемента в конец слайса

	messages := make([]string, 5)
	messages[1] = "1"
	messages = append(messages, "6") // Когда мы выходим за размеры слайса массив, который под капотом у слайса увеличивается в 2 раза
	messages = append(messages, "7")
	messages = append(messages, "8")
	messages = append(messages, "9")
	messages = append(messages, "10")
	messages = append(messages, "11")

	s := []int{5, 3, 6, 8, 1, 2}
	sort.Ints(s)     // Сортировка слайса
	s = s[:len(s)-1] // Удаление последнего элемента в слайсе
	s = s[1:]        // Удаление первого элемента в слайсе

	i := 2
	s = append(s[:i], s[i+1:]...) // Удаление элемента по индексу i

	// Сравнение слайсов
	s1 := []int{1, 2, 3}
	s2 := []int{1, 2, 4}
	fmt.Println(reflect.DeepEqual(s1, s2)) // false

	// Копирование слайсов
	var dest []int
	dest2, dest3 := make([]int, 3), make([]int, 5)
	src := []int{1, 2, 3, 4}
	copy(dest, src)
	copy(dest2, src)
	copy(dest3, src)

	fmt.Println(len(messages)) // len количество элементов в slice
	fmt.Println(cap(messages)) // cap количество элементов в массиве, так как у slice под капотом массив
	fmt.Println(a)
	fmt.Println(mySlice)
	fmt.Println(mySlice2)
	fmt.Println(mySlice3)
	fmt.Println(s)
}